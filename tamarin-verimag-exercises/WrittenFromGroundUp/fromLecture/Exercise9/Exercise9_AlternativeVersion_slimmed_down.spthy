
/*
 *  Author: Julius Figge
 *  Model Name: Exercise9_AlternativeVersion_slimmed_down.spthy
 *  Status: DEVELOPMENTAL
 *
 *  Comments:
 */

theory Exercise9_AlternativeVersion_slimmed_down
begin

builtins: symmetric-encryption
functions: generatedKey/2

rule SetupSymmetricKey:
    [ Fr(~symmetricKey) ]
    --[  ]->
    [ !SymmetricKey($X,$Y,~symmetricKey) ]

rule A_ToB_Init: //A->B : A,N_a
    [ 
        Fr(~nonce_a)
    ]
    --[ 
        Init($A)
    ]->
    [
        State_A_first($A,~nonce_a),
        Out(<$A,~nonce_a>)
    ]

rule B_ToS_SendAndForwardNonce: //B->S : B, {A,N_A,N_B}K_BS
    let 
        message = <A,nonce_a,~nonce_b>
    in
    [ 
        !SymmetricKey($B,$S,symmetricKey_bs),
        In(<A,nonce_a>),
        Fr(~nonce_b)
    ]
    --[ 
        Out_B_nonces(nonce_a,~nonce_b,message)
     ]->
    [ 
        State_B_first($B,$S,A,nonce_a,~nonce_b),    
        Out($B),
        Out(senc(message,symmetricKey_bs)) 
    ]

rule S_ToA_SessionKeyAndMessageToBeForwarded: //S->A : {B,K_AB,N_A,N_B}K_AS, {A,K_AB}K_BS
    let 
     key_ab = generatedKey(nonce_a,nonce_b)
     incomingMessage = <A,nonce_a,nonce_b>
     outgoingMessageNoncesSymmetricKey = <B,key_ab,nonce_a,nonce_b>
     outgoingMessageSymmetricKey = <A,key_ab>
    in
    [ 
        !SymmetricKey(A,S,symmetricKey_as),
        !SymmetricKey(B,S,symmetricKey_bs),
        In(B),
        In(senc(incomingMessage,symmetricKey_bs))
    ]
    --[ 
        In_S_nonces(nonce_a,nonce_b,incomingMessage),
        Out_S_symmetrickey_and_nonces(symmetricKey_as,outgoingMessageNoncesSymmetricKey),
        Out_S_symmetrickey(symmetricKey_bs,outgoingMessageSymmetricKey)
     ]->
    [ 
        Out(senc(outgoingMessageNoncesSymmetricKey,symmetricKey_as)),
        Out(senc(outgoingMessageSymmetricKey,symmetricKey_bs))
    ]

rule A_ToB_Finish: //A->B : {A,K_AB}K_BS, {N_B}K_AB
    let 
        key_ab = generatedKey(nonce_a,nonce_b)
        incomingMessageNoncesSymmetricKey = <B,key_ab,nonce_a,nonce_b>
    in
    [ 
        !SymmetricKey(A,S,symmetricKey_as),
        State_A_first(A,nonce_a),
        In(senc(<B,key_ab,nonce_a,nonce_b>,symmetricKey_as)), 
        In(encryptedGeneratedKeyMessage)
     ]
    --[ 
        In_A_symmetrickey_and_nonces(key_ab,nonce_a,nonce_b,incomingMessageNoncesSymmetricKey)
     ]->
    [ 
        Out(encryptedGeneratedKeyMessage),
        Out(senc(<nonce_b>,key_ab))
    ]

rule B_FinalReceive:
    let 
        key_ab = generatedKey(nonce_a,nonce_b)
        incomingSymmetricKeyMessage = <A,key_ab>
    in
    [ 
        State_B_first(B,S,A,nonce_a,nonce_b),
        !SymmetricKey(B,S,symmetricKey_bs),
        In(senc(incomingSymmetricKeyMessage,symmetricKey_bs)),
        In(senc(<nonce_b>,key_ab))
     ]
    --[ 
        FinishedExchange(A,B,S),
        In_B_symmetrickey(symmetricKey_bs,incomingSymmetricKeyMessage)
    ]->
    [  ]

lemma executable: exists-trace
    "
        All A #i . Init(A)@i ==> Ex B S #j . FinishedExchange(A,B,S)@j
    "

lemma types [sources]:
    " 
        (All nonce_a nonce_b message #i .
            In_S_nonces(nonce_a,nonce_b,message)@i
                ==>
                    ( 
                        (Ex #j #k . 
                            KU(nonce_a)@j & 
                            KU(nonce_b)@k & 
                            #j<#i & 
                            #k<#i) | 
                        (Ex #j . Out_B_nonces(nonce_a,nonce_b,message)@j)
                    )
        )
    "
end
