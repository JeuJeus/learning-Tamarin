
/*
 *  Author: Julius Figge
 *  Model Name: exercise8_1_newApproach.spthy
 *  Status: DEVELOPMENTAL
 *
 *  Comments: 
 * 1. A -> B: {’1’, A, NA}pk(B) //this is asymmetric encryption
 * 2. B -> A: {’2’, A, K}pk(A), {’3’, NA}K //symmetric encryption in the second message
 * 3. A -> B: {’4’, A, B, K}pk(B) //use "builtins: symmetric-encryption, asymmetric-encryption"
 */

theory exercise8_1_newApproach
begin

builtins: asymmetric-encryption, symmetric-encryption

rule Register_Publickey:
    let
      publickey = pk(~privatekey)  
    in
    [ 
        Fr(~privatekey)
     ]
    --[  ]->
    [ 
        !Publickey($X, publickey),
        !Privatekey($X, ~privatekey),
        Out(publickey)
     ]

rule Reveal_Privatekey:
    [ !Privatekey(X,privatekey) ]
    --[ Reveal(X) ]->
    [ Out(privatekey) ]

rule A_Init:
     //1. A -> B: {’1’, A, NA}pk(B)
    let
        message = <'1',$A,~nonce>
        encryptedMessage = aenc(message,publickey_b)
    in
    [ 
        Fr(~nonce),
        !Publickey($B, publickey_b)
     ]
    --[ InitializedProtocol($A,$B,~nonce) ]->
    [ 
        State_A_first($A,$B,~nonce),
        Out(encryptedMessage) ]

rule B_ReceiveInit:
    let
        publickey_b = pk(privatekey_b)

        message = <'1',A,nonce>
        encryptedMessage = aenc(message,publickey_b)
    in
    [ 
        In(encryptedMessage),
        !Privatekey($B,privatekey_b)
     ]
    --[ ReceivedInitializationMessage(A,$B, nonce) ]->
    [ State_B_first($B,A,nonce) ]

rule B_RespondToInit:
     //2. B -> A: {’2’, A, K}pk(A), {’3’, NA}K
    let
        symmetricKeyMessage = <'2',A,~symmetricKey>
        encryptedSymmetricKeyMessage = aenc(symmetricKeyMessage, publickey_a)

        nonceMessage = <'3', nonce>
        encryptedNonceMessage = senc(nonceMessage, ~symmetricKey)
    in
    [ 
        State_B_first(B,A,nonce),
        !Publickey(A, publickey_a),
        Fr(~symmetricKey)
     ]
    --[ 
        SentSymmetricKeyToPartner(B,A,~symmetricKey)
     ]->
    [ 
        State_B_second(B,A,nonce,~symmetricKey),
        Out(encryptedSymmetricKeyMessage),
        Out(encryptedNonceMessage) 
    ]

rule A_ReceiveSymmetricKeyWithMessages:
    let
        publickey_a = pk(privatekey_a)

        symmetricKeyMessage = <'2',A,symmetricKey>
        encryptedSymmetricKeyMessage = aenc(symmetricKeyMessage, publickey_a)

        nonceMessage = <'3', nonce>
        encryptedNonceMessage = senc(nonceMessage, symmetricKey)
    in
    [ 
        In(encryptedSymmetricKeyMessage),
        In(encryptedNonceMessage),
        State_A_first(A,B,nonce),
        !Privatekey(A,privatekey_a)
     ]
    --[ ExtractedSymmetricKey(A,B,symmetricKey) ]->
    [ State_A_second(A,B,nonce,symmetricKey) ]

rule A_RespondViaSymmetricEncryption:
     //3. A -> B: {’4’, A, B, K}pk(B)
    let
        message = <'4',A,B,symmetricKey>
        encryptedMessage = aenc(message,publickey_b)
    in
    [ 
        State_A_second(A,B,nonce,symmetricKey),
        !Publickey(B,publickey_b) 
    ]
    --[  ]->
    [ Out(encryptedMessage) ]

rule B_ReceiveFinalResponse:
    let
        publickey_b = pk(privatekey_b)

        message = <'4',A,B,symmetricKey>
        encryptedMessage = aenc(message,publickey_b)
    in
    [ 
        State_B_second(B,A,nonce,symmetricKey),
        !Privatekey(B, privatekey_b)
     ]
    --[ FinishedExchange(A,B,symmetricKey) ]->
    [  ]

lemma executable:
exists-trace
"
        All A B nonce #i .
        InitializedProtocol(A,B,nonce)@i
            ==>
                Ex symmetricKey #j .
                    FinishedExchange(A,B,symmetricKey)@j
"

lemma secrecy_nonceA:
"
    not(
        Ex A B nonce #i #j.
        ReceivedInitializationMessage(A,B,nonce)@i &
        K(nonce)@j &
        not(Ex #r . Reveal(A)@r) & 
        not(Ex #r . Reveal(B)@r)
    )
"

lemma secrecy_SymmetricKey:
"
    not(
        Ex A B symmetricKey #i #j.
        ExtractedSymmetricKey(A,B,symmetricKey)@i &
        K(symmetricKey)@j &
        not(Ex #r . Reveal(A)@r) & 
        not(Ex #r . Reveal(B)@r)
    )
"
end
